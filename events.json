{"event" : [
         {
		  "name" : "at_rot_target",
		  "name_2" : "at_rot_target(integer number, rotation target_rotation, rotation our_rotation);",
		  "opesanie" : "Это событие вызывается когда обьект определенный как цель(Target) достигает заданного в функции llRotTarget угла . Угловой диапазон устанавливается путем вызова функции llRotTarget.",
		  "url" : "at_rot_target"
		 },
		 {
		  "name" : "at_target",
		  "name_2" : "at_target(integer number, vector target_position, vector our_position);",
		  "opesanie" : "Это событие запускается когда обьект находится в пределах заданного радиуса относительно заданной позиции с помощью функции llTarget . Диапазон и позиция устанавливаются с помощью функции llTarget.",
		  "url" : "at_target"
		 },
		 {
		  "name" : "attach",
		  "name_2" : "attach(key attached);",
		  "opesanie" : "Это событие запускается когда обьект с этим скриптом прикрепляется или отсоединяется от аватара . Если обьект прикрепляется то событию передается ключ аватара , если отсоединяется то передается NULL_KEY. ",
		  "url" : "attach"
		 },
		 {
		  "name" : "changed",
		  "name_2" : "changed(integer changed);",
		  "opesanie" : "Это событие запускается когда производится какое либо действие над обьектом. Параметр changed принимает значение одной константы из набора change constants.",
		  "url" : "changed"
		 },
		 {
		  "name" : "collision",
		  "name_2" : "collision(integer total_number);",
		  "opesanie" : "Это событие запускается тогда когда происходит столкновение этого обьекта с другими обьектами или аватарами. Номера(маркера) обнаруженных обьектов столкновения передаются событию. Информация об этих обьектах может быть получена с помощью библиотечной функции llDetected*. ",
		  "url" : "collision"
		 },
		 {
		  "name" : "collision_end",
		  "name_2" : "collision_end(integer total_number);",
		  "opesanie" : "Это событие запускается тогда когда столкновение этого обьекта с другими обьектами или аватарами прекращено. Номера(маркера) обнаруженных обьектов столкновения передаются событию. Информация об этих обьектах может быть получена с помощью библиотечной функции llDetected*. ",
		  "url" : "collision_end"
		 },
		 {
		  "name" : "collision_start",
		  "name_2" : "collision_start(integer total_number);",
		  "opesanie" : "Это событие запускается тогда когда столкновение этого обьекта с другими обьектами или аватарами только что произошло. Номера(маркера) обнаруженных обьектов столкновения передаются событию. Информация об этих обьектах может быть получена с помощью библиотечной функции llDetected*.",
		  "url" : "collision_start"
		 },
		 {
		  "name" : "control",
		  "name_2" : "control(key name, integer levels, integer edges);",
		  "opesanie" : "Как только скрипт получил возможность захватывать команды ввода от аватара это событие будет запускатся каждый раз при очерредном вводе команды (с клавиатуры). Параметры Level (уровни) и edges (края) принимают значения констант control constants.",
		  "url" : "control"
		 },
		 {
		  "name" : "dataserver",
		  "name_2" : "dataserver(key requested, string data);",
		  "opesanie" : "Это событие запускается когда скипт получает запрошенные данные . Запросы данных можно создавать с помощью функций llRequestAgentData , llRequestSimulatorData, llRequestInventoryData, и llGetNotecardLine.",
		  "url" : "dataserver"
		 },
		 {
		  "name" : "email",
		  "name_2" : "email(string time, string address, string subject, string body, integer remaining);",
		  "opesanie" : "Это событие запускается когда скрипт получает любой емаил . Параметр remaining говорит сколько емайлов осталось еще в очереди.",
		  "url" : "email"
		 },
		 {
		  "name" : "land_collision",
		  "name_2" : "land_collision(vector position);",
		  "opesanie" : "Это событие запускается когда обьект сталкивается с землей. ",
		  "url" : "land_collision"
		 },
		 {
		  "name" : "land_collision_end",
		  "name_2" : "land_collision(vector position);",
		  "opesanie" : "Это событие запускается когда обьект сталкивается с землей.",
		  "url" : "land_collision_end"
		 },
		 {
		  "name" : "land_collision_end",
		  "name_2" : "land_collision_end(vector position);",
		  "opesanie" : "Это событие запускается когда обьект прекращает сталкиватся с землей.",
		  "url" : "land_collision_end"
		 },
		 {
		  "name" : "land_collision_start",
		  "name_2" : "land_collision_start(vector position);",
		  "opesanie" : "Это событие запускается когда обьект начал сталкиватся с землей.",
		  "url" : "land_collision_start"
		 },
		 {
		  "name" : "link_message",
		  "name_2" : "link_message(integer sender_number, integer number, string message, key id);",
		  "opesanie" : "Это событие запускается когда обьект получает сообщение по линии для обьединеных обьектов(залинкованных) через функцию посылки сообщения llMessageLinked.",
		  "url" : "link_message"
		 },
		 {
		  "name" : "listen",
		  "name_2" : "listen(integer channel, string name, key id, string message);",
		  "opesanie" : "Это событие запускается каждый раз когда приходит определенное сообщение по заданному каналу, соответствуя ограничениям, переданным в функцию llListen. Имя Name и идентификатор id также как и сообщения message говорящего, передаются во входных параметрах события. Канал 0 это общественный чатовый канал в котором все аватары видят чат текс. Каналы от 1 до 2,147,483,648 - частные(приватные) каналы, которые не используются аватарами, но при этом скрипты могут прослушивать и отправлять сообщения по этим каналы.",
		  "url" : "listen"
		 },
		 {
		  "name" : "money",
		  "name_2" : "money(key giver, integer amount);",
		  "opesanie" : "Это событие запускается каждый раз когда пользователь giver передаё сумму линден долларов amount обьекту.",
		  "url" : "money"
		 },
		 {
		  "name" : "moving_end",
		  "name_2" : "moving_end(void);",
		  "opesanie" : "Это событие запускается каждый раз когда обект с этим скриптом прекращает движение.",
		  "url" : "moving_end"
		 },
		 {
		  "name" : "moving_start",
		  "name_2" : "moving_start(void);",
		  "opesanie" : "Это событие запускается каждый раз когда обект с этим скриптом только что начал движение.",
		  "url" : "moving_start"
		 },
		 {
		  "name" : "no_sensor",
		  "name_2" : "no_sensor(void);",
		  "opesanie" : "Это событие запускается каждый раз когда датчики активны (посредствам библиотечной функции llSensor) но ничего не воспринимают.",
		  "url" : "no_sensor"
		 },
		 {
		  "name" : "not_at_rot_target",
		  "name_2" : "not_at_rot_target(void);",
		  "opesanie" : "Это событие запускается каждый раз когда цель установленная с помощью функции llRotTarget находится вне указанного угла.",
		  "url" : "not_at_rot_target"
		 },
		 {
		  "name" : "not_at_target",
		  "name_2" : "not_at_target(void);",
		  "opesanie" : "Это событие запускается каждый раз когда цель установленная с помощью функции llTarget находится вне указанного диапазона.",
		  "url" : "not_at_target"
		 },
		 {
		  "name" : "object_rez",
		  "name_2" : "object_rez(key id);",
		  "opesanie" : "Вызывается когда обьект создает другой обьект из своего инвентаря с помощью функции llRezObject . Параметр id это уникальный ключ этого обьекта.",
		  "url" : "object_rez"
		 },
		 {
		  "name" : "on_rez",
		  "name_2" : "on_rez(integer start_param);",
		  "opesanie" : "Вызывается всякий раз когда обьект создается из инвентаря обьекта возле другого обьекта. Входной параметр start_param это параметр переданный вызванной функции llRezObject или llRezAtRoot. Скрипт обработчика этого события может быть расположен в только что созданном обьекте.",
		  "url" : "on_rez"
		 },
		 {
		  "name" : "run_time_permissions",
		  "name_2" : "run_time_permissions(integer permissions);",
		  "opesanie" : "Если скрипт нуждается в разрешении аватара получить какие либо права на какие либо действия прежде чем выплнится определенная функция, такая как снятие средств с текущего щета аккаунта владельца или включение анимации аватара или захват и контроль управления. С помощью функции llRequestPermissions и разнообразных констант permissions integer constants посылаются запросы на получение прав доступа. Обработчик события получает константу текущего набора флагов прав доступа, если возвращается 0 то права доступа не полученны.",
		  "url" : "run_time_permissions"
		 },
		 {
		  "name" : "sensor",
		  "name_2" : "sensor(integer total_number);",
		  "opesanie" : "Это событие запускается всякий раз когда обьект сочетается с ограничениями заданными в функции llSensor -функцией обнаружения. Число обнаруженых предметов передается в параметре total_number . Максимум 16 обьектов может быть переданно в это событие. Информация об этих обьектах может быть получена с помощью библиотечной функции llDetected*.",
		  "url" : "sensor"
		 },
		 {
		  "name" : "state_entry",
		  "name_2" : "state_entry(void);",
		  "opesanie" : "Событие запускается всякий раз когда запускается новое состояние, в том числе и когда стартует программа, и всегда когда запускается первый обработчик событий.",
		  "url" : "state_entry"
		 },
		 {
		  "name" : "state_exit",
		  "name_2" : "state_exit(void);",
		  "opesanie" : "Событие state_exit вызывается когда запускается команда перехода в другое состояние . Оно выполняется перед переходом в новое состояние state_entry события.",
		  "url" : "state_exit"
		 },
		 {
		  "name" : "timer",
		  "name_2" : "timer(void);",
		  "opesanie" : "Это событие постоянно вызывается через заданный интервал времени установленный с помощью библиотечной функции llSetTimerEvent.",
		  "url" : "timer"
		 },
		 {
		  "name" : "touch",
		  "name_2" : "touch(integer total_number);",
		  "opesanie" : "Это событие запускается когда пользователь продолжительно дотрагиваетя до обьекта. Число обьектов к которым прикоснулся пользователь передается в параметре total_number. Информация об этих пользователях может быть собрана с помощью функции llDetected*.",
		  "url" : "touch"
		 },
		 {
		  "name" : "touch_end",
		  "name_2" : "touch_end(integer total_number);",
		  "opesanie" : "Это событие запускается когда пользователь перестал дотрагиваетя до обьекта. Маркер(номер) Аватара который прикоснулся к обьекту передается в параметре total_number. Информация об этих пользователях может быть собрана с помощью библиот функции llDetected*.",
		  "url" : "touch_end"
		 },
		 {
		  "name" : "touch_start",
		  "name_2" : "touch_start(integer total_number);",
		  "opesanie" : "Это событие запускается когда пользователь начал дотрагиваетя до обьекта. Маркер(номер) Аватара который прикоснулся к обьекту передается в параметре total_number. Информация об этих пользователях может быть собрана с помощью библиот функции llDetected*.",
		  "url" : "touch_start"
		 },
		 {
		  "name" : "remote_data",
		  "name_2" : "remote_data(integer type, key channel, key message_id, string sender, integer ival, string sval);",
		  "opesanie" : "Это событие запускается когда пользователь создает XML-RPC канал с помощью функции llOpenRemoteDataChannel ",
		  "url" : "remote_data"
		 },
		 {
		  "name" : "Http_response",
		  "name_2" : "http_response(key request_id, integer status, list metadata, string body);",
		  "opesanie" : "Это событие запускается когда ожидается HTTP ответ на запрос llHTTPRequest или если ожидаемый ответ прерван по ошибке, или если вышло время ответа .",
		  "znak1" : "request_id",
		  "opesanie1" : "получает тотже ключ что был получен в при инициализации запроса с помощью функции llHTTPRequest . Он может быть использован для сверки определенного запроса с определенным ответом на этот запрос .Особенно это полезно когда запросы шлются постоянно и мы не знаем на какой запрос пришел текущщий ответ.",
		  "znak2" : "status",
		  "opesanie2" : "получает информацию о статусе HTTP либо возвращает HTTP ответ или детали о возникшей ошибке если запрос потерпел неудачу.",
		  "znak3" : "metadata",
		  "opesanie3" : "возвращается описание ответа в форме пары <key, value>. В настоящее время может быть возвращен только один ключ HTTP_BODY_TRUNCATED который обозначает длину полученного блока данных если пришлось его обрезать.",
		  "znak4" : "body",
		  "opesanie4" : "находится в теле http-ответа пока ответ включает в себя Content-Type заголовка задание текстовый Тип MIME. Если MIME-Тип Не указан или Тип-Не Тип текста, организм настраивается на Неподдерживаемый или неизвестный Тип содержимого. Если Content-Type заголовка задает набор символов, тело будет указан в теле ответа перекодированы в utf-8, или Неподдерживаемый или неизвестный набор символов. если Кодировка не поддерживается. Тело в настоящее время ограничивается 2049 байт",
		  "url" : "Http_response"
		 }
		 
	]
}